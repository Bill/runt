= Schedule Tutorial

If you haven't done so already, took a look the temporal expression 
tutorial[http://runt.rubyforge.org/doc/files/doc/tutorial_te_rdoc.html].

So, you've defined some temporal expressions, now what? In his 
paper[http://martinfowler.com/apsupp/recurring.pdf] about recurring events, 
Martin Fowler also discusses a simple schedule API which is used, surprisingly
enough, to build a schedule.

We're not going to cover the pattern itself in this tutorial as Fowler already 
does a nice job. Luckily, because it is such a simple pattern (once you invent 
it!), you'll be able understand it even if you decide not to skim the 
aforementioned paper[http://martinfowler.com/apsupp/recurring.pdf].

In the last tutorial we learned about the exciting world of NYC street cleaning 
regulations. For the uptown side of my block, the sign says:
    
    #############################
    #                           #
    #       NO PARKING          #
    #                           #
    #  Mon, Wed, Fri 8am-11am   #
    #                           #
    #   T,Th 11:30am-2:00pm     #
    #                           #
    #  Violators will be towed! #
    #                           #
    #############################
                # #
                # #
                # #
 
We created a temporal expression to match this time period, like so: 

    expr1=(DIWeek.new(Mon) | DIWeek.new(Wed) | DIWeek.new(Fri)) & REDay.new(8,00,11,00)
    
    expr2=(DIWeek.new(Tue) | DIWeek.new(Thu)) & REDay.new(11,30,14,00)
    
    ticket=expr1 | expr2

What we need at this point is a way to associate this expression with the rest 
of our domain model. For this purpose, we can use a Schedule and an associated
Event both of which are supplied by Runt.

A Schedule holds zero or more Event/TemporalExpression pairs, allowing clients
to easily query and update TemporalExpressions as well perform certain range
operations as we will see in a moment.

An Event is simply a container for domain data. Although Runt uses Events 
by default, Schedules will happily house any kind of Object. Internally, a 
Schedule is really just a Hash where the keys are whatever it is you are 
scheduling and the values are the TemporalExpressions you create.


    def add(obj, expression)
      @elems[obj]=expression
    end


For the remainder of this tutorial I will refer to Events specifically, but 
just remember that anything reasonably Hash-keyable will do.


So, let's pretend that I own a car. Since I don't want to get a ticket, I 
decide to create a little cron-like utility daemon to remind myself whenever
it's time for me to move it.

  class Ron


    def run
      loop 
 
    etc...

=.....FINISH ME!......


<em>See Also:</em>

* Fowler's recurring event pattern[http://martinfowler.com/apsupp/recurring.pdf]

* Other temporal patterns[http://martinfowler.com/ap2/timeNarrative.html]
